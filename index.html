<html>
<head>
    <title>CSC3210 Project 3</title>
</head>
<body>
    <canvas id="myCanvas" width="800" height="800"></canvas>

    <script type="module">
import * as THREE from "three";
import * as dat from 'dat.gui';

// above and beyond: help menu with game rules formatted as gui
const gui = new dat.GUI();

const ruleMenu = {
    isOpen: false,
    toggle: function() {
        this.isOpen = !this.isOpen;
        
        document.getElementById('ruleText').style.display = this.isOpen ? 'block' : 'none';
    }
};

gui.add(ruleMenu, 'isOpen').name('Rules').onChange(ruleMenu.toggle.bind(ruleMenu));

// Insert custom HTML for the help text
const ruleText = document.createElement('div');
ruleText.id = 'ruleText';
ruleText.style.display = 'none'; // Initially hidden
ruleText.style.padding = '10px';
ruleText.style.color = '#fff'; // Text color to match GUI theme
ruleText.innerHTML = `
    <p>Welcome to three player war!</p>
    <p>Here's how to play:</p>
    <ul>
        <li>Each player draws one card from their deck and puts it face up in the center of the table</li>
        <li>Player who plays the card with the highest value wins the round</li>
        <li>Winning player takes all cards played during the round</li>
        <li>In the case of a tie, players with cards of equal value will go to war! </li>
        <li>    *Each player in the war will draw three cards and place them face down</li>
        <li>    *Each player then draws a fourth card and plays it face up</li>
        <li>    *Player with highest card value takes ALL cards played during the war</li>
        <li>The player who ends up with all cards in their deck at the end wins </li>
        <li>2 is lowest, ace is highest</li>
    </ul>
`;

// Append the help text element to the GUI container
document.body.appendChild(ruleText);

class MyCamera {
  constructor(xLA, yLA, zLA) {
    this.xLookAt = xLA;
    this.yLookAt = yLA;
    this.zLookAt = zLA;
    this.turnSpeed = 0.1;
    this.animateRotation = false;
    this.animateOtherRotation = false;
    this.cameraRotation = 0.1;

    this.cam = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
    this.cam.position.z = 15;
    this.cam.position.y = 5;
    this.updateLookAt();
  }

  updateLookAt() {
    this.cam.lookAt( new THREE.Vector3( this.xLookAt, this.yLookAt, this.zLookAt ) );
  }
}

// Have a few variables to control the camera

var scene = new THREE.Scene();
var camera = new MyCamera( 0, 0, 0 );
scene.add( camera.cam );

var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true, depth: true});
renderer.setClearColor(0x000000);
// If you want this to span the window, instead of using the myCanvas object, use the window object
renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
// If you want the render to span the window, uncomment this
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
// renderer.physicallyCorrectLights = true;

// Add the geometry
var plane = new THREE.PlaneGeometry(10, 10);
plane.rotateX(-1);
var tableTexture = new THREE.TextureLoader().load('wood.jpg');
var planeMat = new THREE.MeshPhongMaterial({ map: tableTexture });
var planeMesh = new THREE.Mesh(plane, planeMat);
planeMesh.receiveShadow = true;
scene.add( planeMesh );


//creating the deck class
class Deck{
    constructor(){
      this.cards = [];
    }

    addCard(card) {
      this.cards.push(card);
    }

    shuffle(){
      this.cards.sort(() => Math.random() - 0.5);
    }

    drawCard(){
      return this.cards.pop();
    }

    
}


//creating the card class
class Card{
    constructor(texture, value, suit, position){
        this.texture = texture;
        this.value = value;
        this.suit = suit;

        //card geometry
        // this.geometry = new THREE.BoxGeometry(0.1, 2.5, 3.5);  // Thin rectangle
        // this.material = new THREE.MeshPhongMaterial({ map: texture });
        // this.mesh = new THREE.Mesh(this.geometry, this.material);
        // this.mesh.castShadow = true;
        // this.mesh.position.set(position.x, position.y, position.z);
    }

    getSuit(){
          return this.suit;
        }

    getValue(){
      return this.value;
    }
}

// creating a deck of cards by creating 52 card 
function appendToDeck(deck, x, y, z){
    //adding cards one for each in the deck
    const textureLoader = new THREE.TextureLoader();
    for(var i = 0; i < 52; i++){
      var geometry = new THREE.PlaneGeometry(0.75,1.25,3);
      var material = new THREE.MeshBasicMaterial({color: 0x00ff00, side: THREE.DoubleSide});
      //var material = new THREE.TextureLoader().load('PNG-cards-1.3');
      const card = new THREE.Mesh(geometry, material);
      card.position.x = x;
      card.position.y = y;
      card.position.z = z+(i*0.01);
      deck.addCard(card);
      scene.add(card);
    }
}
const deck1 = new Deck();
const deck2 = new Deck();
const deck3 = new Deck();
// creating one deck for each player
appendToDeck(deck1,3,1,1);
appendToDeck(deck2,0,2,1);
appendToDeck(deck3,-3,1,1);
// Add lights
var lights = [];
lights[0] = new THREE.DirectionalLight(0xFFFFFF, 0.5 );
lights[0].position.set(10,10,0);
lights[0].target.position.set(0,0,0);
lights[0].castShadow = true;
lights[0].shadow.mapSize.width = 1024; // try removing these and see what happens
lights[0].shadow.mapSize.height = 1024;
scene.add( lights[ 0 ] );

lights[1] = new THREE.AmbientLight(0xFF0000, 0.5);
scene.add(lights[1]);

lights[2] = new THREE.PointLight(0xFFFFFF, 0.5);
lights[2].position.set( -5, 10, 0 );
lights[2].castShadow = true;
lights[2].intensity = 15;
scene.add( lights[2] );

// Use this for not-necessarily-static scenes or scenes you want to animate
function animate() {
  // If we're rotating the camera change that here.
  if( camera.animateRotation ) 
    // The applyAxisAngle method rotates about an axis in space
    camera.cam.position.applyAxisAngle( new THREE.Vector3(0.0, 1.0, 0.0 ), camera.turnSpeed * 0.1 );
  if( camera.animateOtherRotation ) 
    camera.cam.position.applyAxisAngle( new THREE.Vector3(0.0, 0.0, 1.0 ), camera.turnSpeed * 0.1 );

  camera.updateLookAt();

  requestAnimationFrame( animate );
  renderer.render( scene, camera.cam );
}
animate();

function toggleRotation() {
  camera.animateRotation = !camera.animateRotation;
}
function toggleOtherRotation() {
  camera.animateOtherRotation = !camera.animateOtherRotation;
}

const lightMoveSpeed = 0.5;

// Simple way to setup keybaord controls:
function keyHandler(e) {
  switch(e.keyCode){
    case 78: //key N
      nextTurn();
      break;
    case 76: //L key toggling ambient light
      lights[1].visible = !lights[1].visible;
      break;
    case 80: //p key for toggling point light
      lights[2].visible = !lights[2].visible;
      break;
    case 87: //w key for moving point light forward
      lights[2].position.z += lightMoveSpeed;
      break;
    case 83: // s key for point light backward
      lights[2].position.z -= lightMoveSpeed;
      break;
    case 65: //a key point light left
      lights[2].position.x += lightMoveSpeed;
      break;
    case 68: //d jey point light right
      lights[2].position.x -= lightMoveSpeed;
      break;
    case 77: // M key for toggling shadows
      renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
      break;
  }
}

function animateCardToCenter(cardMesh, targetPosition) {
    const speed = 0.05;

    function moveCard() {
        //Cardâ€™s current position toward the target position
        cardMesh.position.lerp(targetPosition, speed);

        // Check if the card is close enough to stop animation
        if (cardMesh.position.distanceTo(targetPosition) > 0.01) {
            requestAnimationFrame(moveCard); 
        }
    }

    moveCard(); 
}

  // War scenario
function initiateWar(playedCards, decks, highCards) {
    const warCards = [];

    highCards.forEach((value, playerIndex) => {
        const deck = decks[playerIndex];
        if (deck.cards.length >= 4) {
            // Draw cards
            warCards.push(deck.drawCard(), deck.drawCard(), deck.drawCard());
            const warCard = deck.drawCard();
            warCards.push(warCard);
            console.log(`Player ${playerIndex + 1} draws a card with value ${warCard.value} in the war!`);
        } else {
            console.log(`Player ${playerIndex + 1} does not have enough cards for a war.`);
        }
    });

    const warValues = warCards.map(card => card.value);
    const highestWarValue = Math.max(...warValues);
    const winningDeckIndex = warValues.indexOf(highestWarValue) % highCards.length;

    //winning player
    const winnerDeck = decks[winningDeckIndex];
    winnerDeck.cards.push(...playedCards, ...warCards);
    console.log(`Player ${winningDeckIndex + 1} wins the war!`);
}

function nextTurn(deck1, deck2, deck3) {
  if (deck1.cards.length > 0 && deck2.cards.length > 0 && deck3.cards.length > 0) {
        const card1 = deck1.drawCard();
        const card2 = deck2.drawCard();
        const card3 = deck3.drawCard();

        // Move the cards to the center
        animateCardToCenter(card1.mesh, new THREE.Vector3(-1, 0, 0));
        animateCardToCenter(card2.mesh, new THREE.Vector3(0, 0, 0));
        animateCardToCenter(card3.mesh, new THREE.Vector3(1, 0, 0));
        
        // Compare the cards
         // Compare the cards
    if (card1.value === card2.value && card2.value === card3.value) {
      console.log('Tie! A battle occurs among all players.');
      // Implement battle logic for three-way tie if desired
    } else {
      // Determine the highest card and the winner
      const highestValue = Math.max(card1.value, card2.value, card3.value);
      let winnerDeck;

      if (card1.value === highestValue && card2.value === highestValue) {
        console.log('Tie between Player 1 and Player 2! Battle required.');
        
        // each player draws three cards, face down
        const war1 = deck1.drawCard();
        const war2 = deck1.drawCard();
        const war3 = deck1.drawCard();

        const war4 = deck2.drawCard();
        const war5 = deck2.drawCard();
        const war6 = deck2.drawCard();

        // each player draws one card face up to compare
        const p1Card = deck1.drawCard();
        const p2Card = deck2.drawCard();

        if (p1Card > p2Card) {
          winnerDeck = deck1;
          winnerDeck.cards.push(war1, war2, war3, war4, war5, war6, p1Card, p2Card);
        } else {
          winnerDeck = deck2;
          winnerDeck.cards.push(war1, war2, war3, war4, war5, war6, p1Card, p2Card);
        }


      } else if (card2.value === highestValue && card3.value === highestValue) {
          console.log('Tie between Player 2 and Player 3! Battle required.');
          const war1 = deck1.drawCard();
          const war2 = deck1.drawCard();
          const war3 = deck1.drawCard();

          const war4 = deck2.drawCard();
          const war5 = deck2.drawCard();
          const war6 = deck2.drawCard();

          // each player draws one card face up to compare
          const p2Card = deck2.drawCard();
          const p3Card = deck3.drawCard();

          if (p2Card > p3Card) {
            winnerDeck = deck1;
            winnerDeck.cards.push(card1, card2, card3, war1, war2, war3, war4, war5, war6, p2Card, p3Card);
         } else {
            winnerDeck = deck2;
            winnerDeck.cards.push(card1, card2, card3, war1, war2, war3, war4, war5, war6, p2Card, p3Card);
            }
     
      } else if (card1.value === highestValue && card3.value === highestValue) {
        console.log('Tie between Player 1 and Player 3! Battle required.');
        const war1 = deck1.drawCard();
        const war2 = deck1.drawCard();
        const war3 = deck1.drawCard();

        const war4 = deck3.drawCard();
        const war5 = deck3.drawCard();
        const war6 = deck3.drawCard();

        // each player draws one card face up to compare
        const p1Card = deck1.drawCard();
        const p3Card = deck3.drawCard();

        if (p1Card > p2Card) {
          winnerDeck = deck1;
          winnerDeck.cards.push(card1, card2, card3, war1, war2, war3, war4, war5, war6, p1Card, p3Card);
        } else {
          winnerDeck = deck2;
          winnerDeck.cards.push(card1, card2, card3, war1, war2, war3, war4, war5, war6, p1Card, p3Card);
        }


      } else {
        // One player has the highest card, determine winner
        if (card1.value === highestValue) {
          winnerDeck = deck1;
          winnerDeck.cards.push(card1, card2, card3);
          console.log('Player 1 wins this round!');

        } else if (card2.value === highestValue) {
          winnerDeck = deck2;
          winnerDeck.cards.push(card1, card2, card3);
          console.log('Player 2 wins this round!');

        } else {
          winnerDeck = deck3;
          winnerDeck.cards.push(card1, card2, card3);
          console.log('Player 3 wins this round!');
        }       
      }
    }
  } else {
    // Game ends if any player has no cards left
    console.log("Game Over! One player has all the cards.");
  }
}


document.addEventListener( "keydown", keyHandler, false );
    </script>
</body>
</html>